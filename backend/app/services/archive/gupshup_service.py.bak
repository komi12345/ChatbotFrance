"""
Service Gupshup API 2025 - Intégration avec Gupshup WhatsApp API
Remplace whatsapp_service.py pour la migration Meta Cloud API vers Gupshup

Ce service gère :
- L'envoi de messages templates (Message 1)
- L'envoi de messages texte libre (Message 2)
- Le parsing des webhooks Gupshup

ARCHIVED: Ce fichier a été archivé lors de la migration vers Twilio WhatsApp Sandbox.
Voir twilio_service.py pour la nouvelle implémentation.
"""
import json
import logging
import httpx
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from datetime import datetime

from app.config import settings

# Configuration du logger
logger = logging.getLogger(__name__)


@dataclass
class GupshupResponse:
    """
    Réponse de l'API Gupshup.
    
    Attributes:
        success: Indique si la requête a réussi
        message_id: ID du message Gupshup (si succès)
        error_code: Code d'erreur (si échec)
        error_message: Message d'erreur détaillé (si échec)
        raw_response: Réponse brute de l'API pour debug
    """
    success: bool
    message_id: Optional[str] = None
    error_code: Optional[str] = None
    error_message: Optional[str] = None
    raw_response: Optional[Dict[str, Any]] = None


@dataclass
class GupshupWebhookInteraction:
    """
    Interaction parsée depuis un webhook Gupshup.
    
    Attributes:
        contact_phone: Numéro de téléphone du contact (format avec +)
        interaction_type: Type d'interaction ('reply', 'delivered', 'read', 'failed', 'sent')
        content: Contenu du message (pour les réponses)
        gupshup_message_id: ID du message Gupshup
        external_id: ID externe pour le tracking
        timestamp: Horodatage de l'interaction
        contact_name: Nom du contact (si disponible)
    """
    contact_phone: str
    interaction_type: str
    content: Optional[str] = None
    gupshup_message_id: Optional[str] = None
    external_id: Optional[str] = None
    timestamp: Optional[datetime] = None
    contact_name: Optional[str] = None


class GupshupService:
    """
    Service pour l'intégration avec Gupshup API 2025.
    Interface compatible avec l'ancien WhatsAppService pour faciliter la migration.
    
    Différences clés avec Meta Cloud API:
    - Authentification via header 'apikey' (au lieu de Bearer token)
    - Format de requête x-www-form-urlencoded (au lieu de JSON)
    - Numéros de téléphone sans le caractère '+' 
    - Endpoints séparés pour templates (/template/msg) et messages (/msg)
    """
    
    def __init__(self):
        """Initialise le service avec les paramètres de configuration."""
        self.api_key = settings.GUPSHUP_API_KEY
        self.app_name = settings.GUPSHUP_APP_NAME
        self.phone_number = settings.GUPSHUP_PHONE_NUMBER
        self.base_url = settings.GUPSHUP_API_URL
    
    @property
    def template_url(self) -> str:
        """URL de l'endpoint templates Gupshup."""
        return f"{self.base_url}/template/msg"
    
    @property
    def message_url(self) -> str:
        """URL de l'endpoint messages Gupshup."""
        return f"{self.base_url}/msg"
    
    @property
    def headers(self) -> Dict[str, str]:
        """
        Headers pour les requêtes API Gupshup.
        
        Note: Gupshup utilise 'apikey' comme header d'authentification
        et attend du contenu x-www-form-urlencoded.
        """
        return {
            "apikey": self.api_key,
            "Content-Type": "application/x-www-form-urlencoded",
        }
    
    def format_phone_number(self, phone: str) -> str:
        """
        Formate le numéro de téléphone pour Gupshup (sans +).
        
        Gupshup attend les numéros au format international sans le caractère '+'.
        Exemple: +33612345678 -> 33612345678
        
        Args:
            phone: Numéro de téléphone avec ou sans +
        
        Returns:
            Numéro sans le caractère +
        
        Exigences: 2.3, 7.2
        """
        return phone.lstrip("+")

    async def send_template_message(
        self,
        phone: str,
        template_name: str,
        params: List[str] = None,
        language_code: str = "fr"
    ) -> GupshupResponse:
        """
        Envoie un message template WhatsApp (Message 1) via Gupshup.
        
        Args:
            phone: Numéro de téléphone (avec ou sans +)
            template_name: Nom du template approuvé sur Gupshup Dashboard
            params: Liste des paramètres du template (optionnel)
            language_code: Code langue (conservé pour compatibilité, non utilisé par Gupshup)
        
        Returns:
            GupshupResponse avec le résultat de l'envoi
        
        Exigences: 2.1, 2.2, 2.4, 2.5, 2.6
        """
        # Formater le numéro (retirer le +)
        destination = self.format_phone_number(phone)
        
        # Construire le template JSON selon le format Gupshup
        # Format: {"id": "template_name", "params": ["param1", "param2"]}
        template_data: Dict[str, Any] = {"id": template_name}
        if params:
            template_data["params"] = params
        
        # Construire le payload x-www-form-urlencoded
        data = {
            "channel": "whatsapp",
            "source": self.phone_number,
            "destination": destination,
            "template": json.dumps(template_data),
            "src.name": self.app_name
        }
        
        logger.info(
            f"Envoi template Gupshup '{template_name}' à {destination}",
            extra={
                "template_name": template_name,
                "destination": destination,
                "params_count": len(params) if params else 0
            }
        )
        
        return await self._send_request(self.template_url, data)
    
    async def send_text_message(
        self,
        phone: str,
        text: str,
        preview_url: bool = True
    ) -> GupshupResponse:
        """
        Envoie un message texte libre WhatsApp (Message 2) via Gupshup.
        
        Args:
            phone: Numéro de téléphone (avec ou sans +)
            text: Contenu du message texte
            preview_url: Non utilisé par Gupshup mais conservé pour compatibilité
        
        Returns:
            GupshupResponse avec le résultat de l'envoi
        
        Exigences: 3.1, 3.2, 3.3, 3.5, 3.6
        """
        # Formater le numéro (retirer le +)
        destination = self.format_phone_number(phone)
        
        # Construire le message JSON pour Gupshup
        # Format: {"type": "text", "text": "message content"}
        message_data = {
            "type": "text",
            "text": text
        }
        
        # Construire le payload x-www-form-urlencoded
        data = {
            "channel": "whatsapp",
            "source": self.phone_number,
            "destination": destination,
            "message": json.dumps(message_data),
            "src.name": self.app_name
        }
        
        logger.info(
            f"Envoi message texte Gupshup à {destination}",
            extra={
                "destination": destination,
                "text_length": len(text)
            }
        )
        
        return await self._send_request(self.message_url, data)
    
    async def _send_request(self, url: str, data: Dict[str, str]) -> GupshupResponse:
        """
        Envoie une requête à l'API Gupshup avec gestion des erreurs.
        
        Args:
            url: URL de l'endpoint Gupshup
            data: Données à envoyer (format x-www-form-urlencoded)
        
        Returns:
            GupshupResponse avec le résultat
        
        Exigences: 2.5, 2.6, 3.5, 3.6
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    url,
                    headers=self.headers,
                    data=data  # httpx encode automatiquement en x-www-form-urlencoded
                )
                
                response_data = response.json()
                
                logger.debug(
                    f"Réponse Gupshup: status={response.status_code}",
                    extra={"response": response_data}
                )
                
                # Gupshup retourne {"status": "success/error", "messageId": "..."}
                status = response_data.get("status", "").lower()
                
                if response.status_code in [200, 202] and status == "submitted":
                    # Succès - extraire l'ID du message
                    message_id = response_data.get("messageId")
                    
                    logger.info(
                        f"Message Gupshup envoyé avec succès, ID: {message_id}",
                        extra={"message_id": message_id}
                    )
                    
                    return GupshupResponse(
                        success=True,
                        message_id=message_id,
                        raw_response=response_data
                    )
                else:
                    # Erreur API Gupshup
                    error_message = response_data.get("message", "Erreur inconnue")
                    error_code = str(response.status_code)
                    
                    # Gupshup peut retourner des détails d'erreur supplémentaires
                    if "error" in response_data:
                        error_message = response_data.get("error", error_message)
                    
                    logger.error(
                        f"Erreur API Gupshup: {error_code} - {error_message}",
                        extra={
                            "status_code": response.status_code,
                            "error_message": error_message,
                            "response": response_data,
                            "url": url
                        }
                    )
                    
                    return GupshupResponse(
                        success=False,
                        error_code=error_code,
                        error_message=error_message,
                        raw_response=response_data
                    )
                    
        except httpx.TimeoutException as e:
            logger.error(
                f"Timeout lors de l'envoi du message Gupshup: {str(e)}",
                extra={"url": url, "timeout": 30.0}
            )
            return GupshupResponse(
                success=False,
                error_code="timeout",
                error_message="La requête a expiré (30 secondes)"
            )
        except httpx.RequestError as e:
            logger.error(
                f"Erreur réseau lors de l'envoi du message Gupshup: {str(e)}",
                extra={"url": url, "error": str(e)}
            )
            return GupshupResponse(
                success=False,
                error_code="network_error",
                error_message=str(e)
            )
        except json.JSONDecodeError as e:
            logger.error(
                f"Erreur de parsing JSON de la réponse Gupshup: {str(e)}",
                extra={"url": url}
            )
            return GupshupResponse(
                success=False,
                error_code="json_error",
                error_message=f"Réponse invalide de Gupshup: {str(e)}"
            )
        except Exception as e:
            logger.exception(
                f"Erreur inattendue lors de l'envoi du message Gupshup: {str(e)}",
                extra={"url": url}
            )
            return GupshupResponse(
                success=False,
                error_code="internal_error",
                error_message=str(e)
            )

    def parse_webhook_payload(self, payload: Dict[str, Any]) -> List[GupshupWebhookInteraction]:
        """
        Parse le payload d'un webhook Gupshup pour extraire les interactions.
        
        Gupshup envoie deux types de webhooks:
        
        1. Type "message" - Message client reçu:
        {
            "type": "message",
            "mobile": "33612345678",
            "text": "message du client",
            "messageId": "gBEGVzU...",
            "timestamp": 1234567890,
            "name": "Nom du contact"
        }
        
        2. Type "message-event" - Statut de livraison:
        {
            "type": "message-event",
            "eventType": "delivered" | "read" | "failed" | "sent",
            "externalId": "msg_id",
            "messageId": "gBEGVzU...",
            "destAddr": "33612345678"
        }
        
        Args:
            payload: Payload JSON reçu du webhook Gupshup
        
        Returns:
            Liste des interactions extraites
        
        Exigences: 4.1, 5.1
        """
        interactions = []
        
        try:
            webhook_type = payload.get("type", "")
            
            if webhook_type == "message":
                # Parser un message entrant (réponse du client)
                interaction = self._parse_message_webhook(payload)
                if interaction:
                    interactions.append(interaction)
                    
            elif webhook_type == "message-event":
                # Parser un événement de statut (delivered, read, failed)
                interaction = self._parse_status_webhook(payload)
                if interaction:
                    interactions.append(interaction)
            else:
                logger.warning(
                    f"Type de webhook Gupshup non reconnu: {webhook_type}",
                    extra={"payload": payload}
                )
            
            logger.info(
                f"Webhook Gupshup parsé: {len(interactions)} interaction(s) extraite(s)",
                extra={"webhook_type": webhook_type}
            )
            
        except Exception as e:
            logger.exception(
                f"Erreur lors du parsing du webhook Gupshup: {str(e)}",
                extra={"payload": payload}
            )
        
        return interactions
    
    def _parse_message_webhook(self, payload: Dict[str, Any]) -> Optional[GupshupWebhookInteraction]:
        """
        Parse un webhook de type "message" (message client reçu).
        
        Gupshup v2 envoie deux formats possibles:
        
        Format 1 (flat):
        {"type": "message", "mobile": "336...", "text": "...", "messageId": "..."}
        
        Format 2 (nested - utilisé par Gupshup):
        {"type": "message", "payload": {"source": "336...", "payload": {"text": "..."}, "sender": {"phone": "...", "name": "..."}}}
        
        Args:
            payload: Payload du webhook message
        
        Returns:
            GupshupWebhookInteraction ou None si le parsing échoue
        
        Exigences: 4.1
        """
        try:
            # Détecter le format du payload (flat ou nested)
            if "payload" in payload and isinstance(payload.get("payload"), dict):
                # Format nested (Gupshup v2)
                inner_payload = payload.get("payload", {})
                mobile = inner_payload.get("source", "")
                message_id = inner_payload.get("id", "")
                
                # Le texte est dans payload.payload.text
                text_payload = inner_payload.get("payload", {})
                text = text_payload.get("text", "") if isinstance(text_payload, dict) else ""
                
                # Le nom est dans payload.sender.name
                sender = inner_payload.get("sender", {})
                contact_name = sender.get("name") if isinstance(sender, dict) else None
            else:
                # Format flat (ancien format)
                mobile = payload.get("mobile", "")
                text = payload.get("text", "")
                message_id = payload.get("messageId", "")
                contact_name = payload.get("name")
            
            timestamp_unix = payload.get("timestamp")
            
            # Convertir le timestamp Unix en datetime
            # Gupshup envoie le timestamp en millisecondes (13 chiffres)
            dt_timestamp = None
            if timestamp_unix:
                try:
                    ts = int(timestamp_unix)
                    # Si le timestamp a plus de 10 chiffres, c'est en millisecondes
                    if ts > 9999999999:
                        ts = ts / 1000
                    dt_timestamp = datetime.fromtimestamp(ts)
                except (ValueError, TypeError, OSError) as e:
                    logger.warning(f"Timestamp invalide: {timestamp_unix} - {e}")
            
            # Ajouter le + au numéro pour la recherche en DB
            # Gupshup envoie les numéros sans +, mais notre DB les stocke avec +
            contact_phone = f"+{mobile}" if mobile and not mobile.startswith("+") else mobile
            
            return GupshupWebhookInteraction(
                contact_phone=contact_phone,
                interaction_type="reply",
                content=text,
                gupshup_message_id=message_id,
                timestamp=dt_timestamp,
                contact_name=contact_name
            )
            
        except Exception as e:
            logger.error(
                f"Erreur parsing webhook message Gupshup: {str(e)}",
                extra={"payload": payload}
            )
            return None
    
    def _parse_status_webhook(self, payload: Dict[str, Any]) -> Optional[GupshupWebhookInteraction]:
        """
        Parse un webhook de type "message-event" (statut de livraison).
        
        Args:
            payload: Payload du webhook message-event
        
        Returns:
            GupshupWebhookInteraction ou None si le parsing échoue
        
        Exigences: 5.1
        """
        try:
            # Extraire les champs du webhook message-event
            event_type = payload.get("eventType", "").lower()
            external_id = payload.get("externalId")
            message_id = payload.get("messageId", "")
            dest_addr = payload.get("destAddr", "")
            timestamp_unix = payload.get("timestamp")
            
            # Mapper les eventTypes Gupshup vers nos types d'interaction
            # Gupshup: sent, delivered, read, failed
            event_type_map = {
                "sent": "sent",
                "delivered": "delivered",
                "read": "read",
                "failed": "failed",
                "enqueued": None,  # On ignore les événements "enqueued"
            }
            
            interaction_type = event_type_map.get(event_type)
            
            if not interaction_type:
                logger.debug(f"Event type Gupshup ignoré: {event_type}")
                return None
            
            # Convertir le timestamp Unix en datetime
            # Gupshup envoie le timestamp en millisecondes (13 chiffres)
            dt_timestamp = None
            if timestamp_unix:
                try:
                    ts = int(timestamp_unix)
                    # Si le timestamp a plus de 10 chiffres, c'est en millisecondes
                    if ts > 9999999999:
                        ts = ts / 1000
                    dt_timestamp = datetime.fromtimestamp(ts)
                except (ValueError, TypeError, OSError) as e:
                    logger.warning(f"Timestamp invalide: {timestamp_unix} - {e}")
            
            # Ajouter le + au numéro pour la cohérence
            contact_phone = f"+{dest_addr}" if dest_addr and not dest_addr.startswith("+") else dest_addr
            
            return GupshupWebhookInteraction(
                contact_phone=contact_phone,
                interaction_type=interaction_type,
                gupshup_message_id=message_id,
                external_id=external_id,
                timestamp=dt_timestamp
            )
            
        except Exception as e:
            logger.error(
                f"Erreur parsing webhook message-event Gupshup: {str(e)}",
                extra={"payload": payload}
            )
            return None


# Instance singleton du service
gupshup_service = GupshupService()
